.. _ch17:

***********************************
Chapter 17. Slide Deck Manipulation
***********************************

.. topic:: Overview

    Deck Building; Master Pages; Adding a Slide to a Deck; Rearranging a Deck; Appending Two Decks; Exporting a Slide as an Image; Extracting the Text from a Deck

    Examples: |append_slides|_, |copy_slide|_, |extract_txt|_, |m_use|_, |m_slides|_, |p_builder|_, and |slide_2_img|_.

This chapter looks at a number of common tasks performed with slide decks:

.. cssclass:: ul-list

    * building a slide deck based on a file of text notes;
    * using, changing, and creating master pages for slide decks;
    * adding a slide to an existing deck;
    * rearranging the slides in a deck;
    * appending two (or more) decks;
    * exporting a slide from a deck as an image;
    * extracting all the text from a slide deck.

.. _ch17_build_deck:

17.1 Building a Deck from Notes
===============================

With Draw methods such as :py:meth:`~.Draw.title_slide` and :py:meth:`~.Draw.bullets_slide` it's quite easy to write a program that converts a set of notes in a text file into a slides deck.
The |p_builder_py|_ example does just that, using textual input formatted as shown below:

.. cssclass:: rst-collapse

    .. collapse:: Points Builder Text Data

        .. code::

            What is a Algorithm? 

            > An algorithm is a finite set of unambiguous instructions for solving a problem.

            >> An algorithm is correct if on all legitimate inputs, it outputs the right answer in a finite amount of time

            > Can be expressed as
            >>pseudocode
            >>flow charts
            >>text in a natural language (e.g. English)
            >>computer code

            // ======================================================

            Algorithm Design

            > The theoretical  study of how to solve  computational problems
            >>sorting a list of numbers
            >>   finding a shortest route on a map
            >> scheduling when to work on homework
            >> answering web search queries
            >> and so on...

            // ======================================================

            The Importance of Algorithms

            > Their impact is broad and far-reaching.
            >> Internet. Web search, packet routing, ...
            >> Computers. Circuit layout, file system, compilers, ...
            >> Computer graphics. Movies, virtual reality, ...
            >> Security. Cell phones, e-commerce, ...
            >> Multimedia. MP3, JPG, DivX, HDTV, ...
            >> Social networks.  Recommendations, news feeds, ads, ...

            > Their impact is broad and far-reaching.
            >> Internet. Web search, packet routing, ...
            >> Computers. Circuit layout, file system, compilers, ...
            >> Computer graphics. Movies, virtual reality, ...
            >> Security. Cell phones, e-commerce, ...
            >> Multimedia. MP3, JPG, DivX, HDTV, ...
            >> Social networks.  Recommendations, news feeds, ads, ...

            // ======================================================

            Top Ten Algorithms of the Century

            > Ten algorithms having "the greatest influence on the development and practice of science and engineering in the 20th century".

            >> Dongarra and Sullivan, "Computing in Science and Engineering", January/February 2000

            >> Barry Cipra, "The Best of the 20th Century: Editors Name Top 10 Algorithms", SIAM News, Volume 33, Number 4, May 2000
            >>> http://www.siam.org/pdf/news/637.pdf

When |p_builder_py|_ reads this text, it generates three slides shown in :numref:`ch17fig_points_builder_slides`.

..
    figure 1

.. cssclass:: screen_shot

    .. _ch17fig_points_builder_slides:
    .. figure:: https://user-images.githubusercontent.com/4193389/200890963-b4569f69-a647-465a-9154-0ec114c45121.png
        :alt: Slides Generated by points builder
        :width: 550px
        :figclass: align-center

        :Slides Generated by Points Builder

The title slide in :numref:`ch17fig_points_builder_slides` is generated automatically, but the other slides are created from the input text by calling :py:meth:`.Draw.bullets_slide` and :py:meth:`.Draw.add_bullet`.

The reason the output looks so good is that |p_builder_py|_ uses one of Impress' templates, ``Inspiration.otp``.
These files are listed in Impress when you open the "Master Pages" section of the Tasks pane, part of which is shown in :numref:`ch17fig_impress_master_pages`.

..
    figure 2

.. cssclass:: screen_shot

    .. _ch17fig_impress_master_pages:
    .. figure:: https://user-images.githubusercontent.com/4193389/201796280-7d5331da-22a3-4057-9177-f06802d500eb.png
        :alt: The List of Master Pages in Impress.
        :width: 433px
        :figclass: align-center

        :The List of Master Pages in Impress.

If you move the cursor over the thumbnail images, the name of the template file is displayed as a tooltip.

The ``main()`` function of |p_builder_py|_ starts by printing the names of all the available templates, before using ``Inspiration.otp`` to create a new presentation document:

.. tabs::

    .. code-tab:: python

        # partial points_builder.py module
        class PointsBuilder:
            def __init__(self, points_fnm: PathOrStr) -> None:
                _ = FileIO.is_exist_file(fnm=points_fnm, raise_err=True)
                self._points_fnm = FileIO.get_absolute_path(points_fnm)

            def main(self) -> None:
                loader = Lo.load_office(Lo.ConnectPipe())

                # create Impress page or Draw slide
                try:
                    self._report_templates()
                    tmpl_name = "Inspiration.otp"  # "Piano.otp"
                    template_fnm = Path(Draw.get_slide_template_path(), tmpl_name)
                    _ = FileIO.is_exist_file(template_fnm, True)
                    doc = Lo.create_doc_from_template(template_path=template_fnm, loader=loader)

                    self._read_points(doc)

                    print(f"Total no. of slides: {Draw.get_slides_count(doc)}")

                    GUI.set_visible(is_visible=True, odoc=doc)
                    Lo.delay(2000)

                    msg_result = MsgBox.msgbox(
                        "Do you wish to close document?",
                        "All done",
                        boxtype=MessageBoxType.QUERYBOX,
                        buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
                    )
                    if msg_result == MessageBoxResultsEnum.YES:
                        Lo.close_doc(doc=doc, deliver_ownership=True)
                        Lo.close_office()
                    else:
                        print("Keeping document open")
                except Exception:
                    Lo.close_office()
                    raise

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None


``_report_templates()`` uses ``Info.get_dirs("Template")`` to retrieve a list of all the directories examined by Office when looking for templates.
It also calls :py:meth:`.Draw.get_slide_template_path` to retrieve the default slide template directory, and prints the names of the files in that folder:

.. seealso::

    :py:meth:`.Info.get_dirs`

.. tabs::

    .. code-tab:: python

        # in points_builder.py
        def _report_templates(self) -> None:
            template_dirs = Info.get_dirs(setting="Template")
            print("Templates dir:")
            for dir in template_dirs:
                print(f"  {dir}")

            temmplate_dir = Draw.get_slide_template_path()
            print()
            print(f'Templates files in "{temmplate_dir}"')
            template_fnms = FileIO.get_file_paths(temmplate_dir)
            for fnm in template_fnms:
                print(f"  {fnm}")

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. cssclass:: rst-collapse

    .. collapse:: _report_templates()'s output:

        .. code::

            Templates dir:
              C:\Program Files\LibreOffice\share\template\common
              C:\Program Files\LibreOffice\share\template\en-US
              D:\Users\bigby\Documents\Projects\Python\python-ooouno-ex\$BUNDLED_EXTENSIONS\wiki-publisher\templates
              C:\Users\bigby\AppData\Roaming\LibreOffice\4\user\template

            Templates files in "C:\Program Files\LibreOffice\share\template\common\presnt"
              C:\Program Files\LibreOffice\share\template\common\presnt\Beehive.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Blueprint_Plans.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Blue_Curve.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Candy.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\DNA.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Focus.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Forestbird.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Freshes.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Grey_Elegant.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Growing_Liberty.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Inspiration.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Lights.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Metropolis.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Midnightblue.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Nature_Illustration.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Pencil.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Piano.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Portfolio.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Progress.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Sunset.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Vintage.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Vivid.otp
              C:\Program Files\LibreOffice\share\template\common\presnt\Yellow_Idea.otp

|p_builder_py|_ employs the ``Inspiration.otp`` template, via the call:

.. tabs::

    .. code-tab:: python

        tmpl_name = "Inspiration.otp"  # "Piano.otp"
        template_fnm = Path(Draw.get_slide_template_path(), tmpl_name)
        _ = FileIO.is_exist_file(template_fnm, True)
        doc = Lo.create_doc_from_template(template_path=template_fnm, loader=loader)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`.Lo.create_doc_from_template` is a variant of :py:meth:`.Lo.create_doc` which specifies a template for the new document.
It calls ``XComponentLoader.loadComponentFromURL()`` with the template file as an argument, and sets the ``AsTemplate`` property:

.. tabs::

    .. code-tab:: python

        #in the Lo class (simplified)
        _ms_factory: XMultiServiceFactory = None

        @classmethod
        def create_doc_from_template(cls, template_path: PathOrStr, loader: XComponentLoader) -> XComponent:
            if not FileIO.is_openable(template_path):
                raise Exception(f"Template file can not be opened: '{template_path}'")
            Lo.print(f"Opening template: '{template_path}'")
            template_url = FileIO.fnm_to_url(fnm=template_path)

            props = Props.make_props(Hidden=True, AsTemplate=True)
            cls._doc = loader.loadComponentFromURL(template_url, "_blank", 0, props)
            cls._ms_factory = cls.qi(XMultiServiceFactory, cls._doc, raise_err=True)
            return cls._doc

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. seealso::

    .. cssclass:: src-link

        :odev_src_lo_meth:`create_doc_from_template`

The ``_read_points()`` method in |p_builder_py|_ loads the text points file line-by-line.
It ignores blank lines and lines starting with "//", and examines the first character on each line:

.. tabs::

    .. code-tab:: python

        # in points_builder.py
        def _read_points(self, doc: XComponent) -> None:
            curr_slide = Draw.get_slide(doc=doc, idx=0)
            Draw.title_slide(
                slide=curr_slide, title="Python-Generated Slides", sub_title="Using LibreOffice"
            )
            try:

                def process_bullet(line: str, xbody: XText) -> None:
                    # count the number of '>'s to determine the bullet level
                    if xbody is None:
                        print(f"No slide body for {line}")
                        return

                    pos = 0
                    s_lst = [*line]
                    ch = s_lst[pos]
                    while ch == ">":
                        pos += 1
                        ch = s_lst[pos]
                    sub_str = "".join(s_lst[pos:]).strip()
                    Draw.add_bullet(bulls_txt=xbody, level=pos - 1, text=sub_str)

                body: XText = None
                with open(self._points_fnm, "r") as file:
                    # remove empty lines
                    data = (row for row in file if row.strip())
                    # chain generator
                    # strip of remove anything starting //
                    # // for comment
                    data = (row for row in data if not row.lstrip().startswith("//"))

                    for row in data:
                        ch = row[:1]
                        if ch == ">":
                            process_bullet(line=row, xbody=body)
                        else:
                            curr_slide = Draw.add_slide(doc)
                            body = Draw.bullets_slide(slide=curr_slide, title=row.strip())
                print(f"Read in point file: {self._points_fnm.name}")
            except Exception as e:
                print(f"Error reading points file: {self._points_fnm}")
                print(f"  {e}")

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

If the line starts with a ``>``, then ``process_bullet()`` is called to determine how many ``>``'s start the line.
Depending on the number, :py:meth:`.Draw.add_bullet` is called with a different bullet indentation level value.
If the line doesn't start with a ``>``, then it's assumed to be the title line of a new slide, and :py:meth:`.Draw.add_slide` and :py:meth:`.Draw.bullets_slide` create a new bullets-based slide.

.. _ch17_master_pg:

17.2 Master Pages
=================

When a new slide deck is created it always has a single slide and a default master page, and every slide created subsequently will use this master page to format its background.
The easiest way to view the master page is through the Impress GUI – by clicking on the View, Master, Slide Master menu, which displays something like :numref:`ch17fig_default_master_page`.

..
    figure 3

.. cssclass:: screen_shot invert

    .. _ch17fig_default_master_page:
    .. figure:: https://user-images.githubusercontent.com/4193389/201809322-483a529c-52d7-4111-af7a-1e5931860671.png
        :alt: The Default Master Page.
        :figclass: align-center

        :The Default Master Page.

There are five presentation shapes in :numref:`ch17fig_default_master_page`.
From top-to-bottom, left-to-right, they are TitleTextShape_, OutlinerShape_, DateTimeShape_, FooterShape_, and SlideNumberShape_.

Even though a new slide links to this master page, the date/time, footer, and slide number text are not automatically displayed on the slide; their rendering must be turned on.

It's possible to create more master pages in addition to the default one in :numref:`ch17fig_default_master_page`, and link a slide to one of those.

The |m_use_py|_ example illustrates a number of master page features: the default master page has text added to its footer section,
and a shape and text are placed in its top-left corner.
The slide deck holds four slides – three of them link to the default master page, and are set to display its footer and slide number.
However, the third slide in the deck links to a second master page with a slightly different appearance.

:numref:`ch17fig_two_master_page` shows the all the slides in the deck.

..
    figure 4

.. cssclass:: screen_shot invert

    .. _ch17fig_two_master_page:
    .. figure:: https://user-images.githubusercontent.com/4193389/201810565-a75fbff8-9105-4e5d-8034-4825558fb406.png
        :alt: A Slide Deck with Two Master Pages
        :figclass: align-center

        :A Slide Deck with Two Master Pages.

Slides 1, 2, and 4 use the default master page, while slide 3 uses the new master.

The ``main()`` method for |m_use_py|_ is:

.. tabs::

    .. code-tab:: python

        # in master_use.py
        class MasterUse:
            def main(self) -> None:
                loader = Lo.load_office(Lo.ConnectPipe())
                try:
                    doc = Draw.create_impress_doc(loader)

                    # report on the shapes on the default master page
                    master_page = Draw.get_master_page(doc=doc, idx=0)
                    print("Default Master Page")
                    Draw.show_shapes_info(master_page)

                    # set the master page's footer text
                    Draw.set_master_footer(master=master_page, text="Master Use Slides")

                    # add a rectangle and text to the default master page
                    # at the top-left of the slide
                    sz = Draw.get_slide_size(master_page)
                    _ = Draw.draw_rectangle(
                        slide=master_page, x=5, y=7, width=round(sz.Width / 6), height=round(sz.Height / 6)
                    )
                    _ = Draw.draw_text(
                        slide=master_page, msg="Default Master Page",
                        x=10, y=15, width=100, height=10, font_size=24
                    )

                    # set slide 1 to use the master page's slide number
                    # but its own footer text
                    slide1 = Draw.get_slide(doc=doc, idx=0)
                    Draw.title_slide(slide=slide1, title="Slide 1")

                    # IsPageNumberVisible = True: use the master page's slide number
                    # change the master page's footer for first slide;
                    # does not work if the master already has a footer
                    Props.set(
                        slide1, IsPageNumberVisible=True, IsFooterVisible=True, FooterText="MU Slides"
                    )

                    # add three more slides, which use the master page's
                    # slide number and footer
                    for i in range(1, 4):  # 1, 2, 3
                        slide = Draw.insert_slide(doc=doc, idx=i)
                        _ = Draw.bullets_slide(slide=slide, title=f"Slide {i}")
                        Props.set(slide, IsPageNumberVisible=True, IsFooterVisible=True)

                    # create master page 2
                    master2 = Draw.insert_master_page(doc=doc, idx=1)
                    _ = Draw.add_slide_number(master2)

                    print("Master Page 2")
                    Draw.show_shapes_info(master2)

                    # link master page 2 to third slide
                    Draw.set_master_page(slide=Draw.get_slide(doc=doc, idx=2), page=master2)

                    # put ellipse and text on master page 2
                    ellipse = Draw.draw_ellipse(
                        slide=master2, x=5, y=7, width=round(sz.Width / 6), height=round(sz.Height / 6)
                    )
                    Props.set(ellipse, FillColor=CommonColor.GREEN_YELLOW)
                    _ = Draw.draw_text(
                        slide=master2, msg="Master Page 2", x=10, y=15, width=100, height=10, font_size=24
                    )

                    GUI.set_visible(is_visible=True, odoc=doc)

                    Lo.delay(2_000)

                    msg_result = MsgBox.msgbox(
                        "Do you wish to close document?",
                        "All done",
                        boxtype=MessageBoxType.QUERYBOX,
                        buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
                    )
                    if msg_result == MessageBoxResultsEnum.YES:
                        Lo.close_doc(doc=doc, deliver_ownership=True)
                        Lo.close_office()
                    else:
                        print("Keeping document open")
                except Exception:
                    Lo.close_office()
                    raise

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. _ch17_master_pg_access:

17.2.1 Accessing a Master Page
------------------------------

A presentation (or drawing) document can access its master pages through the XMasterPagesSupplier_ interface in the GenericDrawingDocument_ service.
``XMasterPagesSupplier.getMasterPages()`` returns a single XDrawPages_ object:

.. tabs::

    .. code-tab:: python

        mp_supp = Lo.qi(XMasterPagesSupplier, doc)
        pgs = mp_supp.getMasterPages()  # XDrawPages

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The XDrawPages_ object is an indexed collection, with the default master page at position ``0``:

.. tabs::

    .. code-tab:: python

        master_page = Lo.qi(XDrawPage, pgs.getByIndex(0))

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

Note that there's no ``XMasterPage`` interface – both slides and master pages are manipulated using XDrawPage_.

These preceding lines are packaged up as :py:meth:`.Draw.get_master_page`:

.. tabs::

    .. code-tab:: python

        # in the Draw class (overload method, simplified)
        @staticmethod
        def get_master_page(doc: XComponent, idx: int) -> XDrawPage:
            mp_supp = Lo.qi(XMasterPagesSupplier, doc)
            pgs = mp_supp.getMasterPages()
            return Lo.qi(XDrawPage, pgs.getByIndex(idx), True)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

There's a second way of obtaining a master page, via the link between a slide and its master; the linked master is called a target.
This is implemented by an overloaded :py:meth:`.Draw.get_master_page` method:

.. tabs::

    .. code-tab:: python

        # in the Draw class (overload method, simplified)
        @staticmethod
        def get_master_page(slide: XDrawPage) -> XDrawPage:
            mp_target = Lo.qi(XMasterPageTarget, slide, True)
            return mp_target.getMasterPage()

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. seealso::

    .. cssclass:: src-link

        :odev_src_draw_meth:`get_master_page`

.. _ch17_master_pg_what:

17.2.2 What's on a Master Page?
-------------------------------

The default master page was shown in :numref:`ch17fig_default_master_page`, and its structure is confirmed in |m_use_py|_ when :py:meth:`.Draw.show_shapes_info` is called:

.. tabs::

    .. code-tab:: python

        # in main() of master_use.py
        master_page = Draw.get_master_page(doc=doc, idx=0)
        print("Default Master Page")
        Draw.show_shapes_info(master_page)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The output:

::

    Default Master Page
    Draw Page shapes:
      Shape service: com.sun.star.presentation.TitleTextShape; z-order: 0
      Shape service: com.sun.star.presentation.OutlinerShape; z-order: 1
      Shape service: com.sun.star.presentation.DateTimeShape; z-order: 2
      Shape service: com.sun.star.presentation.FooterShape; z-order: 3
      Shape service: com.sun.star.presentation.SlideNumberShape;z-order:4

A new master page is created by using ``XMasterPagesSupplier.getMasterPages()`` and ``XDrawPages.insertNewByIndex()``, as shown in :py:meth:`.Draw.insert_master_page`:

.. tabs::

    .. code-tab:: python

        # in the Draw class
        @staticmethod
        def insert_master_page(doc: XComponent, idx: int) -> XDrawPage:
            try:
                mp_supp = Lo.qi(XMasterPagesSupplier, doc, True)
                pgs = mp_supp.getMasterPages()
                result = pgs.insertNewByIndex(idx)
                if result is None:
                    raise NoneError("None Value: insertNewByIndex() return None")
                return result
            except Exception as e:
                raise DrawPageError("Unable to insert master page") from e

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The new master page contains no presentation shapes (unlike the default one). They must be added separately.

.. _ch17_master_pg_modify:

17.2.3 Modifying a Master Page
------------------------------

|m_use_py|_ changes the default master page in three ways: it adds text to the footer shape (which is empty by default),
and places a blue rectangle and some text in the top-left corner of the master:

.. tabs::

    .. code-tab:: python

        # in main of master_use.py
        # set the master page's footer text
        Draw.set_master_footer(master=master_page, text="Master Use Slides")

        # add a rectangle and text to the default master page
        # at the top-left of the slide
        sz = Draw.get_slide_size(master_page)
        _ = Draw.draw_rectangle(
            slide=master_page, x=5, y=7, width=round(sz.Width / 6), height=round(sz.Height / 6)
        )
        _ = Draw.draw_text(
            slide=master_page, msg="Default Master Page", x=10, y=15, width=100, height=10, font_size=24
        )

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`.Draw.set_master_footer` searches through the shapes on the page looking for a FooterShape_.
The shape is cast to a text interface, and a string added:

.. tabs::

    .. code-tab:: python

        # in the Draw class
        @classmethod
        def set_master_footer(cls, master: XDrawPage, text: str) -> None:
            try:
                footer_shape = cls.find_shape_by_type(
                    slide=master, shape_type=DrawingNameSpaceKind.SHAPE_TYPE_FOOTER
                )
                txt_field = Lo.qi(XText, footer_shape, True)
                txt_field.setString(text)
            except ShapeMissingError:
                raise
            except Exception as e:
                raise DrawPageError("Unable to set master footer") from e

    .. cssclass:: tab-none

        .. group-tab:: None

The second page of |m_use|_ contains no shapes initially.
An ellipse and some text are added to it in the same way as for the default master page:

.. tabs::

    .. code-tab:: python

        # in main of master_use.py
        master2 = Draw.insert_master_page(doc=doc, idx=1)
        _ = Draw.add_slide_number(master2)

        # put ellipse and text on master page 2
        ellipse = Draw.draw_ellipse(
            slide=master2, x=5, y=7, width=round(sz.Width / 6), height=round(sz.Height / 6)
        )
        Props.set(ellipse, FillColor=CommonColor.GREEN_YELLOW)
        _ = Draw.draw_text(
            slide=master2, msg="Master Page 2", x=10, y=15, width=100, height=10, font_size=24
        )

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

Unlike the default master page, a number shape must be explicitly added to the second master, by calling :py:meth:`.Draw.add_slide_number`:

.. tabs::

    .. code-tab:: python

        _ = Draw.add_slide_number(master2)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

It is implemented as:

.. tabs::

    .. code-tab:: python

        # in the Draw class
        @classmethod
        def add_slide_number(cls, slide: XDrawPage) -> XShape:
            try:
                sz = cls.get_slide_size(slide)
                width = 60
                height = 15
                return cls.add_pres_shape(
                    slide=slide,
                    shape_type=PresentationKind.SLIDE_NUMBER_SHAPE,
                    x=sz.Width - width - 12,
                    y=sz.Height - height - 4,
                    width=width,
                    height=height,
                )
            except ShapeError:
                raise
            except Exception as e:
                raise ShapeError("Unable to add slide number") from e

    .. cssclass:: tab-none

        .. group-tab:: None

:py:meth:`.Draw.add_pres_shape` creates a shape from the ``com.sun.star.presentation`` package:

.. tabs::

    .. code-tab:: python

        # in the Draw class
        @classmethod
        def add_pres_shape(
            cls, slide: XDrawPage, shape_type: PresentationKind, x: int, y: int, width: int, height: int
        ) -> XShape:
            try:
                cls.warns_position(slide=slide, x=x, y=y)
                shape = Lo.create_instance_msf(XShape, shape_type.to_namespace(), raise_err=True)
                if shape is not None:
                    slide.add(shape)
                    cls.set_position(shape, x, y)
                    cls.set_size(shape, width, height)
                return shape
            except Exception as e:
                raise ShapeError("Unable to add slide number") from e

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. _ch17_master_pg_use:

17.2.4 Using a Master Page
--------------------------

New slides are automatically linked to the default master page,
but properties must be explicitly set in order for the master's date/time, footer, and page number to be visible on the slide.
For example, the footer and page number are drawn on a slide like so:

.. tabs::

    .. code-tab:: python

        # in main of master_use.py
        slide1 = Draw.get_slide(doc=doc, idx=0)
        
        # ... 

        Props.set(slide1, IsPageNumberVisible=True, IsFooterVisible=True, FooterText="MU Slides")

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The relevant property for showing the date/time is ``IsDateTimeVisible``.
All these properties are define in the |p_draw_service|_ service.

A related property is ``FooterText``, which changes the footer text for a specific slide.

However, this only works if the linked master page doesn't have its own footer text.

A slide can be linked to a different master by calling :py:meth:`.Draw.set_master_page`:

.. tabs::

    .. code-tab:: python

        # in main of master_use.py
        # link master page 2 to third slide
        Draw.set_master_page(slide=Draw.get_slide(doc=doc, idx=2), page=master2)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

It uses the XMasterPageTarget_ interface to create the new link:

.. tabs::

    .. code-tab:: python

        # in the Draw class
        @staticmethod
        def set_master_page(slide: XDrawPage, page: XDrawPage) -> None:
            try:
                mp_target = Lo.qi(XMasterPageTarget, slide, True)
                mp_target.setMasterPage(page)
            except Exception as e:
                raise DrawError("Unable to set master page") from e

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None


.. _ch17_deck_add_slide:

17.3 Adding a Slide to a Deck
=============================

The last section used ``XDrawPages.insertNewByIndex()`` to add a master page to the deck The same method is more commonly employed to add an ordinary slide.

An example is shown in |m_slides_py|_: its ``main()`` methods opens a file, adds a title-only slide at the end of the deck, and a title/subtitle slide at the beginning.
It finishes by saving the modified deck to a new file:

.. tabs::

    .. code-tab:: python

        # in modify_slides.py
        class ModifySlides:
            def __init__(self, fnm: PathOrStr, im_fnm: PathOrStr) -> None:
                _ = FileIO.is_exist_file(fnm=fnm, raise_err=True)
                _ = FileIO.is_exist_file(fnm=im_fnm, raise_err=True)
                self._fnm = FileIO.get_absolute_path(fnm)
                self._im_fnm = FileIO.get_absolute_path(im_fnm)

            def main(self) -> None:
                loader = Lo.load_office(Lo.ConnectPipe())

                try:
                    doc = Lo.open_doc(self._fnm, loader)

                    # slideshow start() crashes if the doc is not visible
                    GUI.set_visible(is_visible=True, odoc=doc)

                    if not Info.is_doc_type(obj=doc, doc_type=Lo.Service.IMPRESS):
                        print("-- Not a slides presentation")
                        Lo.close_office()
                        return

                    slides = Draw.get_slides(doc)
                    num_slides = slides.getCount()
                    print(f"No. of slides: {num_slides}")

                    # add a title-only slide with a graphic at the end
                    last_page = slides.insertNewByIndex(num_slides)
                    Draw.title_only_slide(slide=last_page, header="Any Questions?")
                    Draw.draw_image(slide=last_page, fnm=self._im_fnm)

                    # add a title/subtitle slide at the start
                    first_page = slides.insertNewByIndex(0)
                    Draw.title_slide(
                        slide=first_page, title="Interesting Slides", sub_title="Brought to you by ODEV"
                    )

                    Lo.delay(2000)
                    msg_result = MsgBox.msgbox(
                        "Do you wish to close document?",
                        "All done",
                        boxtype=MessageBoxType.QUERYBOX,
                        buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
                    )
                    if msg_result == MessageBoxResultsEnum.YES:
                        Lo.close_doc(doc=doc, deliver_ownership=True)
                        Lo.close_office()
                    else:
                        print("Keeping document open")
                except Exception:
                    Lo.close_office()
                    raise

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

But if you examine the new file, you'll see that the title/subtitle slide has become the second slide in the deck.
This highlights a restriction on ``XDrawPages.insertNewByIndex()``, which is that a new slide cannot be inserted at index position ``0``.
Instead, it will be inserted at the next spot, position ``1``.

.. _ch017_rearranging_slide_deck:

17.4 Rearranging a Slide Deck
=============================

A surprising gap in the presentation API is the lack of a simple way to rearrange slides: for example, to move the second slide to the fifth position.

The closest the API comes is the ability to duplicate a slide, but the copy is always inserted after the original, so isn't of much use.
If you did want to do this, the code would be something like:

.. tabs::

    .. code-tab:: python

        dup = Lo.qi(XDrawPageDuplicator, doc)
        dup_slide = dup.duplicate(slide)  # XDrawPage
            # dup_slide is located after original slide in the deck

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The only way to rearrange slides inside Office is with dispatch commands, in particular with the "Copy" and "Paste" commands.
This is complicated by the fact that copying an entire slide is only possible when the deck is displayed in slide-sorter mode.

.. todo::

    Chapter 17.4, Add link to chapters 51

The |copy_slide_py|_ example illustrates the technique but, as with most uses of dispatching, is quite fragile.
The better answer is to utilize a third-part API, the ODF Toolkit, which is the topic of Chapter 51.

|copy_slide_start_py|_ is called with three arguments – the filename and two slide indices.

The first index is the source slide's position in the deck, and the second is the position after which the copied slide will appear.
For instance:

::

    python -m start points.odp 1 4

will copy the second slide of the deck to after the fifth slide.

The ``main()`` method of |copy_slide_py|_:

.. tabs::

    .. code-tab:: python

        # in copy_slide.py
        def main(self) -> None:
            loader = Lo.load_office(Lo.ConnectPipe())

            try:
                doc = Lo.open_doc(fnm=self._fnm, loader=loader)
                num_slides = Draw.get_slides_count(doc)
                if self._from_idx >= num_slides or self._to_idx >= num_slides:
                    Lo.close_office()
                    raise IndexError("One or both indicies are out of range")

                GUI.set_visible(is_visible=True, odoc=doc)

                self._copy_to(doc=doc)

                # Draw.delete_slide(doc=doc, idx=self._from_idx)
                # a problem if the copying changes the indices

                # Lo.save(doc) # overwrites original

                Lo.delay(2000)
                msg_result = MsgBox.msgbox(
                    "Do you wish to close document?",
                    "All done",
                    boxtype=MessageBoxType.QUERYBOX,
                    buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
                )
                if msg_result == MessageBoxResultsEnum.YES:
                    Lo.close_doc(doc=doc, deliver_ownership=True)
                    Lo.close_office()
                else:
                    print("Keeping document open")
            except IndexError:
                raise
            except Exception:
                Lo.close_office()
                raise

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None


All the interesting stuff is performed by ``_copy_to()``.
One minor thing to note is the call to :py:meth:`.Lo.save` in ``main()`` which causes the changed slide deck to be saved back to its original file.

It is defined as:

.. tabs::

    .. code-tab:: python

        # in Lo class
        @classmethod
        def save(cls, doc: object) -> bool:
            cargs = CancelEventArgs(Lo.save.__qualname__)
            cargs.event_data = {"doc": doc}
            _Events().trigger(LoNamedEvent.DOC_SAVING, cargs)
            if cargs.cancel:
                return False

            store = cls.qi(XStorable, doc, True)
            try:
                store.store()
                cls.print("Saved the document by overwriting")
            except IOException as e:
                raise Exception(f"Could not save the document") from e

            _Events().trigger(LoNamedEvent.DOC_SAVED, EventArgs.from_args(cargs))
            return True

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

It is often best to avoid calling :py:meth:`.Lo.save` due to the fact that it overwrites the input file.

The call to  :py:meth:`.Draw.delete_slide` in ``main()`` is commented out due to its potential to cause damage.
The problem is that the new slide may cause the overall indexing of the slide deck to change.
For example, consider what happens if the fourth slide is copied to after the second slide.
This will create a new third slide, moving the old third slide, and all later slides, to the right.
If the program now deletes the fourth slide, that's not the slide that's just been copied, but the repositioned third slide.

The ``_copy_to()`` function in |copy_slide_py|_:

.. tabs::

    .. code-tab:: python

        # in copy_slide.py
        def _copy_to(self, doc: XComponent) -> None:
            # Copy fromIdx slide to the clipboard in slide-sorter mode,
            # then paste it to after the toIdx slide.

            ctrl = GUI.get_current_controller(doc)

            # Switch to slide sorter view so that slides can be pasted
            Lo.delay(1000)
            Lo.dispatch_cmd(cmd=DrawViewDispatch.DIA_MODE)

            # give Office a few seconds of time to do it
            Lo.delay(3000)

            from_slide = Draw.get_slide(doc, self._from_idx)
            to_slide = Draw.get_slide(doc, self._to_idx)

            Draw.goto_page(ctrl, from_slide)
            Lo.dispatch_cmd(cmd=GlobalEditDispatch.COPY)
            Lo.delay(500)
            print(f"Copied {self._from_idx}")

            Draw.goto_page(ctrl, to_slide)
            Lo.delay(500)
            Lo.dispatch_cmd(GlobalEditDispatch.PASTE)
            Lo.delay(500)
            print(f"Paste to after {self._to_idx}")

            # Lo.dispatchCmd("PageMode");  // back to normal mode (not working)
            Lo.dispatch_cmd(cmd=DrawDrawingDispatch.DRAWING_MODE)
            Lo.delay(500)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None


The method sends out four dispatches: the ``DiaMode`` command switches the application into slide-sorter mode, and is followed by ``Copy``, ``Paste``,
and finally ``DrawingMode`` which switches the mode back to normal.

Dispatch lookups from :ref:`utils_dispatch` namespace are used for convenience.

There are a few complications.
One is that :py:meth:`.Draw.goto_page` must be called twice.
The first call ensures that the source slide is the visible, active window before the ``Copy`` is processed.
The second :py:meth:`.Draw.goto_page` call makes sure the destination slide is now visible.
This means that ``Paste`` will insert the copied slide after the destination slide, as required.

Normally the call is :py:meth:`.Draw.goto_page` with a document argument (:abbreviation:`e.g.` ``Draw.goto_page(doc, from_slide)``).
This does not work correctly for the pasting of the slide, for reasons unknown.
The solution is to use a reference to the document's controller, as shown in ``_copy_to()``:

.. tabs::

    .. code-tab:: python

        # in _copy_to()
        ctrl = GUI.get_current_controller(doc)
        # ...
        Draw.goto_page(ctrl, from_slide)
        # ...
        Draw.goto_page(ctrl, to_slide)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. _ch17_deck_append:

17.5 Appending Slide Decks Together
===================================

.. todo::

    Chapter 17.5, Add link to chapters 51

A common Office forum question is how to add the slides of one deck to the end of another.
One solution is to use ``Copy`` and ``Paste`` dispatches as in :ref:`ch017_rearranging_slide_deck`, but in a more complicated fashion.
As you might guess, the ``ODF Toolkit library`` described in Chapter 51 is a better solution, but the focus is on using Office here.

This approach means that two application windows could be open at the same time: one containing the deck that is being copied, and another for the destination slide deck.
This requires references to two different application views and frames, which can be a problem because of the Static design of many classes.

Another problem is caused by the issue of master page copying.
When a slide using a different master page is copied to a deck, Impress will query the user with an 'Confirmation' dialog asking if the copied slide's
format (:abbreviation:`e.g.` its master page) should be copied over to the destination deck.
The dialog looks like :numref:`ch17fig_confirmation_dlg`.

..
    figure 5

.. cssclass:: screen_shot invert

    .. _ch17fig_confirmation_dlg:
    .. figure:: https://user-images.githubusercontent.com/4193389/201975901-7564b1e8-9a62-4fe9-bb8e-5866e7d4a42f.png
        :alt: Confirmation Dialog screen shot
        :figclass: align-center

        :Confirmation Dialog

If you want the format of the copied deck to be retained in its new location, then you have to click the "Yes" button.
Carrying out this clicking action programmatically requires stepping outside the Office API, and is using |odevgui_win|_ to interact with the dialog box.

The resulting code is in the |append_slides_py|_ example.
The ``main()`` function mostly processes the ``*fnms`` of ``__init__`` arguments, a list of filenames.
The first file is the destination deck for the slides copied from the other files:

.. tabs::

    .. code-tab:: python

        # in append_slides.py (partial class)

        class AppendSlides:
            def __init__(self, *fnms: PathOrStr) -> None:
                if len(fnms) == 0:
                    raise ValueError("At lease one file is required. fnms has no values.")
                for fnm in fnms:
                    _ = FileIO.is_exist_file(fnm, True)

                self._fnms = fnms

            def main(self) -> None:
                loader = Lo.load_office(Lo.ConnectPipe())

                try:
                    doc = Lo.open_doc(fnm=self._fnms[0], loader=loader)

                    GUI.set_visible(is_visible=True, odoc=doc)

                    self._to_ctrl = GUI.get_current_controller(doc)
                    self._to_frame = GUI.get_frame(doc)

                    # Switch to slide sorter view so that slides can be pasted
                    Lo.delay(500)
                    Lo.dispatch_cmd(cmd=DrawViewDispatch.DIA_MODE, frame=self._to_frame)

                    to_slides = Draw.get_slides(doc)
                    
                    # monitor for Confirmation dialog
                    if DialogAuto:
                        DialogAuto.monitor_dialog('y')

                    for fnm in self._fnms[1:]:  # start at 1
                        try:
                            app_doc = Lo.open_doc(fnm=fnm, loader=loader)
                        except Exception as e:
                            print(f'Could not open the file "{fnm}"')
                            print(f"  {e}")
                            continue

                        self._append_doc(to_slides=to_slides, doc=app_doc)

                    Lo.delay(500)
                    # Lo.dispatch_cmd(cmd=DrawViewDispatch.PAGE_MODE, frame=self._to_frame)  # does not work
                    Lo.dispatch_cmd(cmd=DrawDrawingDispatch.DRAWING_MODE)
                    Lo.delay(1000)

                    msg_result = MsgBox.msgbox(
                        "Do you wish to close document?",
                        "All done",
                        boxtype=MessageBoxType.QUERYBOX,
                        buttons=MessageBoxButtonsEnum.BUTTONS_YES_NO,
                    )
                    if msg_result == MessageBoxResultsEnum.YES:
                        Lo.close_doc(doc=doc,deliver_ownership=True)
                        Lo.close_office()
                    else:
                        print("Keeping document open")
                except Exception:
                    Lo.close_office()
                    raise

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

Dispatch lookups from :ref:`utils_dispatch` namespace are used for convenience.

Note that the controller and frame reference for the destination deck are saved as instance Variables of class.

.. tabs::

    .. code-tab:: python

        # in AppendSlides.main() of append_slides.py
        self._to_ctrl = GUI.get_current_controller(doc)
        self._to_frame = GUI.get_frame(doc)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

This is done this to reduce the number of arguments passed between the methods.

The for-loop in the middle of ``main()`` processes each of the slide decks in turn, appending their slides to the destination deck.

``_append_doc()`` accesses a slide deck in a second Impress window, which means that a second controller and frame reference are needed; they're stored in ``self._to_ctrl`` and ``self._to_frame``:

.. tabs::

    .. code-tab:: python

        # in AppendSlides of append_slides.py
        def _append_doc(self, to_slides: XDrawPages, doc: XComponent) -> None:
            # Append doc to the end of  toSlides.
            # Access the slides in the document, and the document's controller and frame refs.
            # Switch to slide sorter view so that slides can be copied.
            GUI.set_visible(is_visible=True, odoc=doc)

            from_ctrl = GUI.get_current_controller(doc)
            from_frame = GUI.get_frame(doc)
            Lo.dispatch_cmd(cmd="DiaMode", frame=from_frame)
            try:
                from_slides = Draw.get_slides(doc)
                print("- Adding slides")
                self._append_slides(
                    to_slides=to_slides, from_slides=from_slides,
                    from_ctrl=from_ctrl, from_frame=from_frame
                )
            except mEx.DrawPageMissingError:
                print("- No Slides Found")

            # Lo.dispatchCmd("PageMode");  // back to normal mode (not working)
            Lo.dispatch_cmd(cmd=DrawDrawingDispatch.DRAWING_MODE)
            Lo.close_doc(doc)
            print()

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

``_append_doc()`` calls ``_append_slides()`` to cycle through the slides, copying each one to the destination deck:

.. tabs::

    .. code-tab:: python

        # in AppendSlides of append_slides.py
        def _append_slides(self,
            to_slides: XDrawPages, from_slides: XDrawPages, from_ctrl: XController, from_frame: XFrame
        ) -> None:
            # Append fromSlides to the end of toSlides
            # Loop through the fromSlides, copying each one.
            for i in range(from_slides.getCount()):
                from_slide = Draw.get_slide(from_slides, i)

                # the copy will be placed after this slide
                to_slide = Draw.get_slide(to_slides, to_slides.getCount() - 1)

                self._copy_to(
                    from_slide=from_slide,
                    from_ctrl=from_ctrl,
                    from_frame=from_frame,
                    to_slide=to_slide,
                    to_ctrl=self._to_ctrl,
                    to_frame=self._to_frame,
                )

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The for-loop in ``_append_slides()`` calls ``_copy_to()`` which copies and pastes a slide using dispatch commands.
In addition ( for Windows ), it deals with the 'Confirmation' dialog in :numref:`ch17fig_confirmation_dlg` by way of |odevgui_win|_.

.. tabs::

    .. code-tab:: python

        # in main() of append_slides.py
        # monitor for Confirmation dialog
        if DialogAuto:
            DialogAuto.monitor_dialog('y')

    .. cssclass:: tab-none

        .. group-tab:: None

.. seealso::

    :external+odevguiwin:ref:`class_dialog_auto`

The ``_copy_to()`` Method:

.. tabs::

    .. code-tab:: python

        # in AppendSlides of append_slides.py
        def _copy_to(
            self,
            from_slide: XDrawPage,
            from_ctrl: XController,
            from_frame: XFrame,
            to_slide: XDrawPage,
            to_ctrl: XController,
            to_frame: XFrame,
        ) -> None:
            # Copy fromSlide to the clipboard, and
            # then paste it to after the toSlide. Unfortunately, the
            # paste requires a "Yes" button to be pressed.

            Draw.goto_page(from_ctrl, from_slide)  # select this slide
            print("-- Copy -->")
            Lo.dispatch_cmd(cmd=GlobalEditDispatch.COPY, frame=from_frame)
            Lo.delay(1000)

            Draw.goto_page(to_ctrl, to_slide)
            print("Paste")

            Lo.dispatch_cmd(cmd=GlobalEditDispatch.PASTE, frame=to_frame)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

The |append_slides|_ and |copy_slide|_ examples highlight important missing features in the presentation API.
Copying and pasting a slide in a deck should be available as methods in XDrawPages_.

.. todo::

    Chapter 17.5, Add link to chapters 51

If you need a robust way of doing these tasks then take a look at the ODF Toolkit library in Chapter 51.

.. _ch17_export_img:

17.6 Exporting a Slide as an Image
==================================

A drawing or slide can be exported as an image by using the GraphicExportFilter_ service and its XGraphicExportFilter_ interface.
The service is represented in :numref:`ch17fig_gf_service_interfaces_methods`.

..
    figure 6

.. cssclass:: diagram invert

    .. _ch17fig_gf_service_interfaces_methods:
    .. figure:: https://user-images.githubusercontent.com/4193389/201988141-95297898-e9fc-48ad-96ba-76b412e4f74d.png
        :alt: The Graphic Export Filter Service, Interfaces, and Methods.
        :figclass: align-center

        :The GraphicExportFilter_ Service, Interfaces, and Methods.

In older documentation, such as the Developer's Guide, there's no mention of XGraphicExportFilter_.
The guide claims that GraphicExportFilter_ directly supports XExporter_, XFilter_, and XMimeTypeInfo_.

The |append_slides_start_py|_ for |slide_2_img|_ example read three arguments from the command line:
the filename ``--file`` of the slide deck, the index number of the slide ``--idx``, and the format used for saving the slide's image ``--out_fmt``.

For example:

::

    python -m start --file "resources/presentation/algs.ppt" --out_fmt "jpeg" --idx 0

Optionally |append_slides_start_py|_ also reads a ``--output_dir`` that determines where output is saved.

Use ``python -m start -h`` to see all options.

The index number (``--idx``) value may be a source of confusion since slides are numbered from 1 inside Impress' GUI, but from 0 in the API.
In this case index is zero based so, ``--idx 2`` means the third slide in the deck.

The ``main()`` function for |slide_2_img_py|_:

.. tabs::

    .. code-tab:: python

        # Slide2Image.main() in slide_2_image.py
        def main(self) -> None:
            # connect headless. will not need to see slides
            with Lo.Loader(Lo.ConnectPipe(headless=True)) as loader:
                doc = Lo.open_doc(fnm=self._fnm, loader=loader)

                if not Info.is_doc_type(obj=doc, doc_type=Lo.Service.IMPRESS):
                    Lo.print("-- Not a slides presentation")
                    return

                slide = Draw.get_slide(doc=doc, idx=self._idx)

                names = ImagesLo.get_mime_types()
                Lo.print("Known GraphicExportFilter mime types:")
                for name in names:
                    Lo.print(f"  {name}")

                out_fnm = self._out_dir / f"{self._fnm.stem}{self._idx}.{self._img_fmt}"
                Lo.print(f'Saving page {self._idx} to "{out_fnm}"')
                mime = ImagesLo.change_to_mime(self._img_fmt)
                Draw.save_page(page=slide, fnm=out_fnm, mime_type=mime)
                Lo.close_doc(doc)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

Note how connection to LibreOffice is done with in ``headless`` mode.
This basically runs LibreOffice in the background without a GUI interface.

.. seealso::

    :ref:`conn_connect_pipe`

The example uses two mime functions: :py:meth:`.ImagesLo.get_mime_types` and :py:meth:`ImagesLo.change_to_mime`.
The first returns an array of all the mime types supported by GraphicExportFilter_ by calling ``XMimeTypeInfo.getSupportedMimeTypeNames()``:

.. tabs::

    .. code-tab:: python

        # in ImagesLo class
        @staticmethod
        def get_mime_types() -> Tuple[str, ...]:
            mi = Lo.create_instance_mcf(
                XMimeTypeInfo, "com.sun.star.drawing.GraphicExportFilter", raise_err=True
            )
            return mi.getSupportedMimeTypeNames()

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. cssclass:: rst-collapse

    .. collapse:: The printed output:

        ::

            Known GraphicExportFilter mime types:
              image/x-MS-bmp
              image/x-emf
              image/x-eps
              image/gif
              image/jpeg
              image/x-met
              image/x-portable-bitmap
              image/x-pict
              image/x-portable-graymap
              image/png
              image/x-portable-pixmap
              image/x-cmu-raster
              image/svg+xml
              image/x-svm
              image/tiff
              image/x-wmf
              image/x-xpixmap

:py:meth:`.ImagesLo.change_to_mime` looks through the mime array for a type that contains the supplied format as a substring:

.. tabs::

    .. code-tab:: python

        # in ImagesLo class
        @classmethod
        def change_to_mime(cls, im_format: str) -> str:
            names = cls.get_mime_types()
            imf = im_format.lower().strip()
            for name in names:
                if imf in name:
                    print(f"using mime type: {name}")
                    return name
            print("No matching mime type, so using image/png")
            return "image/png"

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`Draw.save_page` creates an XGraphicExportFilter_ object, configuring it with the page to be exported and the mime type filter:

.. tabs::

    .. code-tab:: python

        # in Draw class (simplified)
        @staticmethod
        def save_page(page: XDrawPage, fnm: PathOrStr, mime_type: str) -> None:
            save_file_url = FileIO.fnm_to_url(fnm)
            Lo.print(f'Saving page in "{fnm}"')

            # create graphics exporter
            gef = Lo.create_instance_mcf(
                XGraphicExportFilter, "com.sun.star.drawing.GraphicExportFilter", raise_err=True
            )

            # set the output 'document' to be specified page
            doc = Lo.qi(XComponent, page, True)
            # link exporter to the document
            gef.setSourceDocument(doc)

            # export the page by converting to the specified mime type
            props = Props.make_props(MediaType=mime_type, URL=save_file_url)

            gef.filter(props)
            Lo.print("Export Complete")

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. seealso::

    .. cssclass:: src-link

        :odev_src_draw_meth:`save_page`

The name of the ``XExporter.setSourceDocument()`` method is a bit misleading since its input argument should either be an
XDrawPage_ (a slide, as here), XShape_ (a shape on the slide), or an XShapes_ object (a collection of shapes on a slide).

``XFilter.filter()`` exports the slide (or shape), based on values supplied in a properties array.
The array should contain the mime type and the URL of the output file.

.. _ch17_extract_slide_text:

17.7 Extracting the Text from a Slide Deck
==========================================

:py:meth:`.Draw.get_shapes_text` supports the fairly common task of extracting all the text from a presentation.
It is used by the |extract_txt|_ example:

.. tabs::

    .. code-tab:: python
        :emphasize-lines: 17, 18, 19, 20, 21, 22

        # extract_text.py
        from __future__ import annotations
        from ooodev.utils.lo import Lo
        from ooodev.office.draw import Draw
        from ooodev.utils.type_var import PathOrStr
        from ooodev.utils.file_io import FileIO

        class ExtractText:
            def __init__(self, fnm: PathOrStr) -> None:
                _ = FileIO.is_exist_file(fnm=fnm, raise_err=True)
                self._fnm = FileIO.get_absolute_path(fnm)

            def main(self) -> None:
                with Lo.Loader(Lo.ConnectPipe(headless=True)) as loader:
                    doc = Lo.open_doc(fnm=self._fnm, loader=loader)

                    if Draw.is_shapes_based(doc):
                        print("Text Content".center(46, "-"))
                        print(Draw.get_shapes_text(doc))
                        print("-" * 46)
                    else:
                        print("Text extraction unsupported for this document type")

                    Lo.delay(1000)
                    Lo.close_doc(doc)

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`.Draw.get_shapes_text` calls :py:meth:`~.Draw.get_ordered_shapes` to collect all the shapes from all the slides in the document.
It then iterates over the shapes list, converting each shape to text and adding it to a String List:

.. tabs::

    .. code-tab:: python

        # in Draw Class (simplified)
        @classmethod
        def get_shapes_text(cls, doc: XComponent) -> str:
            sb: List[str] = []
            shapes = cls.get_ordered_shapes(doc)
            for shape in shapes:
                text = cls.get_shape_text(shape)
                sb.append(text)
            return "\n".join(sb)

    .. cssclass:: tab-none

        .. group-tab:: None


:py:meth:`.Draw.get_shape_text` pulls the text from a shape by casting it to a text interface, then uses a cursor to select the text:

.. tabs::

    .. code-tab:: python

        # in Draw Class (overload method, simplified)
        @classmethod
        def get_shape_text(cls, shape: XShape) -> str:
            try:
                xtext = Lo.qi(XText, shape, True)
                xtext_cursor = xtext.createTextCursor()
                xtext_rng = Lo.qi(XTextRange, xtext_cursor, True)
                text = xtext_rng.getString()
                return text
            except Exception as e:
                raise DrawError("Error getting shape text from shape") from e

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`.Draw.get_ordered_shapes` iterates over each slide in the document calling another version of itself to extract the shapes from a slide:

.. tabs::

    .. code-tab:: python

        # in Draw Class (overload method, simplified)
        @classmethod
        def get_ordered_shapes(cls, doc: XComponent) -> List[XShape]:
            # get all the shapes in all the pages of the doc, in z-order per slide
            slides = cls.get_slides_list(doc)
            if not slides:
                return []
            shapes: List[XShape] = []
            for slide in slides:
                shapes.extend(cls.get_ordered_shapes(slide))
            return shapes

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. seealso::

    .. cssclass:: src-link

        * :odev_src_draw_meth:`get_ordered_shapes`
        * :odev_src_draw_meth:`get_shape_text`
        * :odev_src_draw_meth:`get_shapes_text`

The ordering of the shapes in a slide may not match their reading order (:abbreviation:`i.e.` top- down, left-to-right).
For example, a slide is read by first looking at the text in the ``TitleShape``, before reading the bullets below in the ``OutlinerShape``.
However, ``TitleShape`` may be stored at the end of the slide's container.

:py:meth:`.Draw.get_ordered_shapes` deals with the problem by extracting all the shapes from the slide into a list, and then sorting it based on each shape's z-order.
A shape with z-order ``0`` will be moved before a shape with z-order ``1``.
This almost always corresponds to the user's reading order of the shapes.
For example, ``TitleShape`` usually has a z-order of ``0``.

.. tabs::

    .. code-tab:: python

        # in Draw Class (overload method, simplified)
        @classmethod
        def get_ordered_shapes(cls, slide: XDrawPage) -> List[XShape]:
            def sorter(obj: XShape) -> int:
                return cls.get_zorder(obj)

            shapes = cls.get_shapes(slide)
            sorted_shapes = sorted(shapes, key=sorter, reverse=False)
            return sorted_shapes

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

:py:meth:`Draw.get_shapes` extracts all the shapes from a slide as a list:

.. tabs::

    .. code-tab:: python

        # in Draw Class (overload method, simplified)
        @classmethod
        def get_shapes(cls, slide: XDrawPage) -> List[XShape]:
            if slide.getCount() == 0:
                Lo.print("Slide does not contain any shapes")
                return []

            shapes: List[XShape] = []
            for i in range(slide.getCount()):
                shapes.append(Lo.qi(XShape, slide.getByIndex(i), True))
            return shapes

    .. only:: html

        .. cssclass:: tab-none

            .. group-tab:: None

.. seealso::

    .. cssclass:: src-link

        * :odev_src_draw_meth:`get_shapes`
        * :odev_src_draw_meth:`get_ordered_shapes`

.. |p_builder| replace:: Points Builder
.. _p_builder: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_points_builder

.. |p_builder_py| replace:: points_builder.py
.. _p_builder_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_points_builder/points_builder.py

.. |m_use| replace:: Master Use
.. _m_use: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_master_use

.. |m_use_py| replace:: master_use.py
.. _m_use_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_master_use/master_use.py

.. |m_slides| replace:: Modify Slides
.. _m_slides: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_modify_slides

.. |m_slides_py| replace:: modify_slides.py
.. _m_slides_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_modify_slides/modify_slides.py

.. |copy_slide| replace:: Copy Slide
.. _copy_slide: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_copy_slide

.. |copy_slide_py| replace:: copy_slide.py
.. _copy_slide_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_copy_slide/copy_slide.py

.. |copy_slide_start_py| replace:: start.py
.. _copy_slide_start_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_copy_slide/start.py

.. |append_slides| replace:: Append Slides
.. _append_slides: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_append_slides

.. |append_slides_py| replace:: append_slides.py
.. _append_slides_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_append_slides/append_slides.py

.. |append_slides_start_py| replace:: start.py
.. _append_slides_start_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_append_slides/start.py

.. |slide_2_img| replace:: Slide to Image
.. _slide_2_img: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_slide_to_image

.. |slide_2_img_py| replace:: slide_2_image.py
.. _slide_2_img_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_slide_to_image/slide_2_image.py

.. |p_draw_service| replace:: com.sun.star.presentation.DrawPage
.. _p_draw_service: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1DrawPage.html

.. |extract_txt| replace:: Extract Text
.. _extract_txt: https://github.com/Amourspirit/python-ooouno-ex/tree/main/ex/auto/impress/odev_extract_text

.. |extract_txt_py| replace:: extract_text.py
.. _extract_txt_py: https://github.com/Amourspirit/python-ooouno-ex/blob/main/ex/auto/impress/odev_extract_text/extract_text.py

.. _DateTimeShape: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1presentation_1_1DateTimeShape.html
.. _FooterShape: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1presentation_1_1FooterShape.html
.. _GenericDrawingDocument: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1GenericDrawingDocument.html
.. _GraphicExportFilter: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1drawing_1_1GraphicExportFilter.html
.. _OutlinerShape: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1presentation_1_1OutlinerShape.html
.. _SlideNumberShape: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1presentation_1_1SlideNumberShape.html
.. _TitleTextShape: https://api.libreoffice.org/docs/idl/ref/servicecom_1_1sun_1_1star_1_1presentation_1_1TitleTextShape.html
.. _XDrawPage: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XDrawPage.html
.. _XDrawPages: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XDrawPages.html
.. _XExporter: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1document_1_1XExporter.html
.. _XFilter: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1document_1_1XFilter.html
.. _XGraphicExportFilter: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XGraphicExportFilter.html
.. _XMasterPagesSupplier: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XMasterPagesSupplier.html
.. _XMasterPageTarget: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XMasterPageTarget.html
.. _XMimeTypeInfo: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1document_1_1XMimeTypeInfo.html
.. _XShape: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XShape.html
.. _XShapes: https://api.libreoffice.org/docs/idl/ref/interfacecom_1_1sun_1_1star_1_1drawing_1_1XShapes.html
